#!/usr/bin/python

# (c) 2013 Jose Angel de Bustos Perez <jadebustos@gmail.com>
#     Distributed under GNU GPL v2 License
#     See COPYING.txt for more details

#
# python document-modules.py module_dir module_name python_file
#
#	/usr/bin/python2.6 document-modules.py /usr/lib/pymodules/python2.6/numpy numarray session.py
#         /usr/lib/pymodules/python2.6/numpy/numarray/session.py
#
#      /usr/bin/python2.6 document-modules.py /usr/lib/pymodules/python2.6/numpy . dual.pyc
#        /usr/lib/pymodules/python2.6/numpy/dual.pyc
#

import os, sys, inspect, types

#
# check if right number of argments are passed
#

def checkArgs(args):
	rc = True
	if len(args) <= 3:
		rc = False
	return rc

#
# Function to create a HTML table with function arguments
#  argsList = inspect.getargspec(python_module_function)
#

def argsFunc2HtmlTable(argsList):
	htmlCode = '<table border="1"><tr><td align="center">args</td><td align="center">varargs</td><td align="center">keywords</td><td align="center">defaults</td></tr><tr>'
	for i in range(4):
		if type(argsList[i]) is tuple or list:
			htmlCode += '<td align="center">' + str(argsList[i]) +'</td>'
		else:
			htmlCode += '<td align="center">None</td>'
	htmlCode += '</tr></table>'
	return htmlCode 

#
# Function to document a python module
#

def docPythonModule(moduleFile,module):
	classes = {}
	functions = {}
	methods = {}
	(name, ext) = os.path.splitext(moduleFile)
	if module == '.':
		moduleName = name
	else:
		moduleName = module + "." + name
	docFileName = moduleName + ".html"
	importString = "import " + moduleName +" as " + name
	exec(importString)
	exec("callable = inspect.getmembers(" + name +",callable)")
	docFileDescr = open(docFileName, 'w')
	docFileDescr.write('<html>\n\t<body>\n')
	docFileDescr.write('<center>Documentation generated by document-modules.py<br>')
	docFileDescr.write('<blockquote>May the m &sdot; a be with you.</blockquote></center>')
	docFileDescr.write('<h1>Callable objects in ' + moduleName +'</h1>\n')
	execStringFunctions = "functionsTmp = inspect.getmembers("+ name +",inspect.isfunction)"
	execStringClasses = "classesTmp = inspect.getmembers("+ name +",inspect.isclass)"
	exec(execStringFunctions)
	exec(execStringClasses)
	if len(classesTmp) != 0:
		for item in classesTmp:
			execStringClasses = "classes[item[0]] = inspect.formatargspec(inspect.getclasstree(inspect.getmro("+ name + "."+ item[0] + ")))"
			exec(execStringClasses)
		for key in classes.keys():
			txt = '<h2>Class ' + key + '</h2>Class tree:<blockquote>' + classes[key] + '</blockquote>\n'
			docFileDescr.write(txt)
			txt = inspect.getdoc(key)
			if type(txt) is not types.NoneType:
				docFileDescr.write('<h3>' + key + ' class documentation available:</h3>')	
				docFileDescr.write(txt)
			txt = inspect.getcomments(key)
			if type(txt) is not types.NoneType:
				docFileDescr.write('<h3>' + key + ' class comments available:</h3>')
				docFileDescr.write(txt)
			execStringClassMethods = "methods = inspect.getmembers(" + name + "."+ key +",inspect.ismethod)"
			exec(execStringClassMethods)
			if len(methods) >= 1:
				for method in methods:
					execStringMethArgs="mthArgs = inspect.getargspec(" + name + "." + key + "." + method[0] + ")"
					exec(execStringMethArgs)
					docFileDescr.write('<h3>' + name + '.' + key + '.' + method[0] + ' method:</h3>')
					txt = argsFunc2HtmlTable(mthArgs)
					docFileDescr.write(txt)
			execStringClassFunctions = "functions = inspect.getmembers(" + name + "."+ key +",inspect.isfunction)"
			exec(execStringClassFunctions)
			if len(functions) >= 1:
				for function in functions:
					myFunction = name + '.' + key + '.' + method[0]
					execStringFuncArgs="funcArgs = inspect.getargspec(" + myFunction + ")"
					exec(execStringFuncArgs)
					txt = inspect.getdoc(myFunction)
					if type(txt) is not types.NoneType:		
						docFileDescr.write('<h3>' + myFunction + ' function documentation available:</h3>')
						docFileDescr.write(txt)
					docFileDescr.write('<h3>' + myFunction + ' function arguments:</h3>')
					txt = argsFunc2HtmlTable(funcArgs)
					docFileDescr.write(txt)
					txt = inspect.getcomments(funcArgs)
					if type(txt) is not types.NoneType:
						docFileDescr.write('<h3>' + myFunction + ' function comments available:</h3>')
						docFileDescr.write(txt)
	if len(functionsTmp) != 0:
		for item in functionsTmp:
			myFunction = name + '.' + item[0]
			execStringFunctions = "functions = inspect.getargspec("+ myFunction + ")"
			exec(execStringFunctions)
			txt = '<h2>Function '+ myFunction + '</h2>'
			docFileDescr.write(txt)
			txt = inspect.getdoc(item)
			if type(txt) is not types.NoneType:
				docFileDescr.write('<h3>' + myFunction + ' function documentation available:</h3>')
				docFileDescr.write(txt)			
			docFileDescr.write('<h3>' + myFunction + ' function arguments:</h3>')
			txt = argsFunc2HtmlTable(functions)
                        docFileDescr.write(txt)
			txt = inspect.getcomments(item)
			if type(txt) is not types.NoneType:
				docFileDescr.write('<h3>Comments available:</h3>')
				docFileDescr.write(txt)
	
#
# main function
#

def main (args):
	rc = checkArgs(args)
	if rc == False:
		print "Python files need to be supplied as arguments."
		sys.exit(1)

	# add library path
	lib_path = os.path.abspath(args[1])
	sys.path.append(lib_path)

	module = args[2]

	files = args[3::1]

	for file in files:
		docPythonModule(file,module)
	
if __name__ == "__main__":
	main(sys.argv)

